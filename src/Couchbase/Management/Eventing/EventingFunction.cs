using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text.Json;
using System.Text.Json.Serialization;
using Couchbase.Management.Eventing.Internal;
using Couchbase.Query;
using Couchbase.Utils;

namespace Couchbase.Management.Eventing
{
    /// <summary>
    /// Eventing Functions offers a computing paradigm using which developers can handle data changes
    /// via the handlers of OnUpdate or OnDelete. Resources are managed at or above the Eventing
    /// Function level, and the containing Eventing Function scopes the state of all handlers.
    /// </summary>
    [JsonConverter(typeof(EventingFunctionConverter))]
    public class EventingFunction
    {
        /// <summary>
        /// The app name.
        /// </summary>
        /// <remarks>Required. The minimum length is 1 and the max length is 100.</remarks>
        public string Name { get; set; }

        /// <summary>
        /// The handler's code.
        /// </summary>
        /// <remarks>Required. The minimum length is 1.</remarks>
        public string Code { get; set; }

        /// <summary>
        /// Authoring tool. use 'external' if authored or edited outside eventing ui.
        /// </summary>
        public string Version { get; internal set; } = "external";

        /// <summary>
        /// Enforces stricter validation for all settings and configuration fields.
        /// </summary>
        public bool EnforceSchema { get; set; }

        /// <summary>
        /// Unique id of the the handler. Generated by server.
        /// </summary>
        public long HandlerUuid { get; internal set; }

        /// <summary>
        /// Unique id of the deployment of the handler. Generated by server.
        /// </summary>
        public string FunctionInstanceId { get; internal set; }

        public EventingFunctionKeyspace MetaDataKeySpace
        {
            get => new(DeploymentConfig.MetadataBucket,
                DeploymentConfig.MetadataScope, DeploymentConfig.MetadataCollection);
            set
            {
                DeploymentConfig.MetadataBucket = value.Bucket;
                DeploymentConfig.MetadataScope = value.Scope;
                DeploymentConfig.MetadataCollection = value.Collection;
            }
        }

        public EventingFunctionKeyspace SourceKeySpace
        {
            get =>
                new(DeploymentConfig.SourceBucket,
                    DeploymentConfig.SourceScope, DeploymentConfig.SourceCollection);
            set
            {
                DeploymentConfig.SourceBucket = value.Bucket;
                DeploymentConfig.SourceScope = value.Scope;
                DeploymentConfig.SourceCollection = value.Collection;
            }
        }

        /// <summary>
        /// Any additional configuration settings.
        /// </summary>
        /// <remarks>Required.</remarks>
        public EventingFunctionSettings Settings { get; set; } = new();

        /// <summary>
        /// The deployment configuration.
        /// </summary>
        /// <remarks>Required.</remarks>
        internal DeploymentConfig DeploymentConfig { get; set; } = new();

        public string ToJson() =>
            JsonSerializer.Serialize(this, EventingSerializerContext.Primary.EventingFunction);
    }

    /// <summary>
    /// The deployment configuration.
    /// </summary>
    public class DeploymentConfig
    {
        /// <summary>
        /// The bucket to listen to for document mutations.
        /// </summary>
        /// <remarks>The min length is 1 and the max is 100.</remarks>
        [JsonPropertyName("source_bucket")]
        [JsonPropertyOrder(3)]
        public string SourceBucket { get; set; }

        /// <summary>
        /// The scope to listen to for document mutations.
        /// </summary>
        /// <remarks>The min length is 1 and the max is 30.</remarks>
        [JsonPropertyName("source_scope")]
        [JsonPropertyOrder(4)]
        public string SourceScope { get; set; }

        /// <summary>
        /// The collection to listen to for document mutations.
        /// </summary>
        /// <remarks>The min length is 1 and the max is 30.</remarks>
        [JsonPropertyName("source_collection")]
        [JsonPropertyOrder(5)]
        public string SourceCollection { get; set; }

        /// <summary>
        /// The bucket to store eventing checkpoints and timers.
        /// </summary>
        /// <remarks>The min length is 1 and the max is 100.</remarks>
        [JsonPropertyName("metadata_bucket")]
        [JsonPropertyOrder(6)]
        public string MetadataBucket{ get; set; }

        /// <summary>
        /// The scope to store eventing checkpoints and timers.
        /// </summary>
        /// <remarks>The min length is 1 and the max is 30.</remarks>
        [JsonPropertyName("metadata_scope")]
        [JsonPropertyOrder(7)]
        public string MetadataScope { get; set; }

        /// <summary>
        /// The collection to store eventing checkpoints and timers.
        /// </summary>
        /// <remarks>The min length is 1 and the max is 30.</remarks>
        [JsonPropertyName("metadata_collection")]
        [JsonPropertyOrder(8)]
        public string MetadataCollection { get; set; }

        /// <summary>
        /// The bucket bindings.
        /// </summary>
        /// <remarks>Optional.</remarks>
        [JsonPropertyName("buckets")]
        [JsonPropertyOrder(0)]
        public List<EventingFunctionBucketBinding> BucketBindings { get; set; } = new();

        /// <summary>
        /// The url bindings.
        /// </summary>
        /// <remarks>Optional.</remarks>
        [JsonPropertyName("curl")]
        [JsonPropertyOrder(1)]
        public List<EventingFunctionUrlBinding> UrlBindings { get; set; } = new();

        /// <summary>
        /// The constant bindings.
        /// </summary>
        /// <remarks>Optional.</remarks>
        [JsonPropertyName("constants")]
        [JsonPropertyOrder(2)]
        public List<EventingFunctionConstantBinding> ConstantBindings { get; set; } = new();
    }

    /// <summary>
    /// The key-space for an eventing function. May represent a source or meta-data key-space.
    /// </summary>
    public class EventingFunctionKeyspace
    {
        public EventingFunctionKeyspace(string bucketName, string scopeName, string collectionName)
        {
            Bucket = bucketName;
            Scope = scopeName;
            Collection = collectionName;
        }

        /// <summary>
        /// The bucket name.
        /// </summary>
        public string Bucket { get; }

        /// <summary>
        /// The scope name.
        /// </summary>
        public string Scope { get; }

        /// <summary>
        /// The collection name.
        /// </summary>
        public string Collection { get; }
    }

    /// <summary>
    /// Bucket aliases allow JavaScript handlers to access Couchbase KV collections from the Data Service or KV.x
    /// </summary>
    [JsonConverter(typeof(EventingFunctionBucketBindingConverter))]
    public class EventingFunctionBucketBinding
    {
        /// <summary>
        /// Symbolic name used in code to refer to this binding.
        /// </summary>
        /// <remarks>Required. The min length is 1 and the max length is 20.</remarks>
        public string Alias { get; set; }

        /// <summary>
        /// The name of the bucket this binding maps to.
        /// </summary>
        /// <remarks>Required. The min length is 1 and the max length is 100.</remarks>
        internal string BucketName { get; set; }

        /// <summary>
        /// The name of the scope this binding maps to.
        /// </summary>
        /// <remarks>The min length is 1 and the max length is 30.</remarks>
        internal string ScopeName { get; set; }

        /// <summary>
        /// The name of the collection this binding maps to.
        /// </summary>
        /// <remarks>The min length is 1 and the max length is 100.</remarks>
        internal string CollectionName { get; set; }

        public EventingFunctionKeyspace Name => new(BucketName, ScopeName, CollectionName);

        /// <summary>
        /// The bucket access level (read or read+write).
        /// </summary>
        /// <remarks>Required.</remarks>
        public EventingFunctionBucketAccess Access { get; set; }
    }

    /// <summary>
    /// The eventing function bucket access required.
    /// </summary>
    public enum EventingFunctionBucketAccess
    {
        [Description("r")]
        ReadOnly,

        [Description("rw")]
        ReadWrite
    }

    /// <summary>
    /// These bindings are utilized by the cURL language construct to access external resources.
    /// </summary>
    [JsonConverter(typeof(EventingFunctionUrlBindingConverter))]
    public class EventingFunctionUrlBinding
    {
        /// <summary>
        /// Full URL (including any path) that this binding connects.
        /// </summary>
        /// <remarks>Required. The minimum length is 1.</remarks>
        [JsonPropertyName("hostname")]
        public string Hostname { get; set; }

        /// <summary>
        /// Allow cookies on the session.
        /// </summary>
        /// <remarks>Required. The default is true.</remarks>
        [JsonPropertyName("allow_cookies")]
        public bool AllowCookies { get; set; } = true;

        /// <summary>
        /// Validate remote server certificate using OS mechanisms.
        /// </summary>
        /// <remarks>Required.</remarks>
        [JsonPropertyName("validate_ssl_certificate")]
        public bool ValidateSslCertificate { get; set; }

        /// <summary>
        /// Symbolic name used in code to refer to this binding
        /// </summary>
        /// <remarks>Required. The minimum length is 1 and the max is 20.</remarks>
        [JsonPropertyName("value")]
        public string Alias { get; set; }

        /// <summary>
        /// The http authentication method to use with this endpoint.
        /// </summary>
        [JsonIgnore]
        public IEventingFunctionUrlAuth Auth { get; set; } = new EventingFunctionUrlNoAuth();

        [Obsolete]
        public Newtonsoft.Json.Linq.JObject ToJson()
        {
            var root = new Newtonsoft.Json.Linq.JObject(Auth.ToJson())
            {
                new Newtonsoft.Json.Linq.JProperty("hostname", Hostname),
                new Newtonsoft.Json.Linq.JProperty("allow_cookies", Hostname),
                new Newtonsoft.Json.Linq.JProperty("validate_ssl_certificate", Hostname),
                new Newtonsoft.Json.Linq.JProperty("value", Alias)
            };

            return root;
        }
    }

    /// <summary>
    /// The authentication type to use.
    /// </summary>
    public interface IEventingFunctionUrlAuth
    {
        [Obsolete]
        List<Newtonsoft.Json.Linq.JProperty> ToJson();
    }

    /// <summary>
    /// Internal variant of <see cref="IEventingFunctionUrlAuth"/> which handles JSON serialization.
    /// </summary>
    internal interface ISerializableEventingFunctionUrlAuth : IEventingFunctionUrlAuth
    {
        void WriteToObject(Utf8JsonWriter writer);
    }

    /// <summary>
    /// Do not use authentication.
    /// </summary>
    public class EventingFunctionUrlNoAuth : ISerializableEventingFunctionUrlAuth
    {
        [Obsolete]
        public List<Newtonsoft.Json.Linq.JProperty> ToJson()
        {
            return new ()
            {
                new Newtonsoft.Json.Linq.JProperty("auth_type", "no-auth")
            };
        }

        void ISerializableEventingFunctionUrlAuth.WriteToObject(Utf8JsonWriter writer)
        {
            writer.WriteString("auth_type", "no-auth");
        }
    }

    /// <summary>
    /// Basic authentication.
    /// </summary>
    public class EventingFunctionUrlAuthBasic : ISerializableEventingFunctionUrlAuth
    {
        /// <summary>
        /// The username for http auth methods that use it.
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// The password for http auth methods that use it.
        /// </summary>
        public string Password { get; set; }

        [Obsolete]
        public List<Newtonsoft.Json.Linq.JProperty> ToJson()
        {
            return new()
            {
                new Newtonsoft.Json.Linq.JProperty("password", Password),
                new Newtonsoft.Json.Linq.JProperty("username", Username),
                new Newtonsoft.Json.Linq.JProperty("auth_type", "basic")
            };
        }

        void ISerializableEventingFunctionUrlAuth.WriteToObject(Utf8JsonWriter writer)
        {
            writer.WriteString("password", Password);
            writer.WriteString("username", Username);
            writer.WriteString("auth_type", "basic");
        }
    }

    /// <summary>
    /// Digest authentication.
    /// </summary>
    public class EventingFunctionUrlAuthDigest : ISerializableEventingFunctionUrlAuth
    {
        /// <summary>
        /// The username for http auth methods that use it.
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// The password for http auth methods that use it.
        /// </summary>
        public string Password { get; set; }

        [Obsolete]
        public List<Newtonsoft.Json.Linq.JProperty> ToJson()
        {
            return new()
            {
                new Newtonsoft.Json.Linq.JProperty("password", Password),
                new Newtonsoft.Json.Linq.JProperty("username", Username),
                new Newtonsoft.Json.Linq.JProperty("auth_type", "digest")
            };
        }

        void ISerializableEventingFunctionUrlAuth.WriteToObject(Utf8JsonWriter writer)
        {
            writer.WriteString("password", Password);
            writer.WriteString("username", Username);
            writer.WriteString("auth_type", "digest");
        }
    }

    /// <summary>
    /// Auth-bearer authentication.
    /// </summary>
    public class EventingFunctionUrlAuthBearer : ISerializableEventingFunctionUrlAuth
    {
        /// <summary>
        /// The bearer key for bearer auth.
        /// </summary>
        public string Key { get; set; }

        [Obsolete]
        public List<Newtonsoft.Json.Linq.JProperty> ToJson()
        {
            return new()
            {
                new Newtonsoft.Json.Linq.JProperty("bearer_key", Key),
                new Newtonsoft.Json.Linq.JProperty("auth_type", "bearer")
            };
        }

        void ISerializableEventingFunctionUrlAuth.WriteToObject(Utf8JsonWriter writer)
        {
            writer.WriteString("bearer_key", Key);
            writer.WriteString("auth_type", "bearer");
        }
    }

    /// <summary>
    /// These bindings are utilized by the Functionâ€™s JavaScript handler code as global variables.
    /// </summary>
    public class EventingFunctionConstantBinding
    {
        /// <summary>
        /// The alias name of the constant binding.
        /// </summary>
        /// <remarks>Optional. The min length is 1 and the max is 20.</remarks>
        [JsonPropertyName("value")]
        public string Alias { get; set; }

        /// <summary>
        /// The literal value bound to the alias name.
        /// </summary>
        [JsonPropertyName("literal")]
        public string Literal { get; set; }
    }

    /// <summary>
    /// Advanced settings that may be adjusted.
    /// </summary>
    [JsonConverter(typeof(EventingFunctionSettingsConverter))]
    public class EventingFunctionSettings
    {
        /// <summary>
        /// Number of threads each worker utilizes.
        /// </summary>
        /// <remarks>Minimum is 1.</remarks>
        public int CppWorkerThreadCount { get; set; } = 2;

        /// <summary>
        /// Indicates where to start dcp stream from (beginning of time, present point) 'from_prior' is deprecated in 6.6.2.
        /// </summary>
        public EventingFunctionDcpBoundary DcpStreamBoundary { get; set; } = EventingFunctionDcpBoundary.Everything;

        /// <summary>
        /// Free form text for user to describe the handler. no functional role.
        /// </summary>
        public string Description { get; set; } = string.Empty;

        /// <summary>
        /// Indicates if the function is deployed. true=deployed, false=undeployed.
        /// </summary>
        public EventingFunctionDeploymentStatus DeploymentStatus { get; set; } =
            EventingFunctionDeploymentStatus.Undeployed;

        /// <summary>
        /// Indicates if the function is running (i.e., not paused). true=running, false=paused.
        /// </summary>
        public EventingFunctionProcessingStatus ProcessingStatus { get; set; } =
            EventingFunctionProcessingStatus.Paused;

        /// <summary>
        /// Eventing language version this handler assumes in terms of syntax and behavior.
        /// </summary>
        /// <remarks>Default is '6.6.2'.</remarks>
        public EventingFunctionLanguageCompatibility LanguageCompatibility { get; set; } = EventingFunctionLanguageCompatibility.Version_6_6_2;

        /// <summary>
        /// Level of detail in system logging.
        /// </summary>
        /// <remarks>Default is INFO.</remarks>
        public EventingFunctionLogLevel LogLevel { get; set; } = EventingFunctionLogLevel.Info;

        /// <summary>
        /// Maximum time the handler can run before it is forcefully terminated (in seconds).
        /// </summary>
        /// <remarks>The minimum is 1 and the default is 60s.</remarks>
        public TimeSpan ExecutionTimeout { get; set; } = TimeSpan.FromSeconds(60);

        /// <summary>
        /// Maximum number of libcouchbase connections that may be opened and pooled.
        /// </summary>
        /// <remarks>The minimum is 1 and the default is 10.</remarks>
        public int LcbInstCapacity { get; set; } = 10;

        /// <summary>
        /// Number of retries of retriable libcouchbase failures. 0 keeps trying till execution_timeout.
        /// </summary>
        /// <remarks>The default is 0.</remarks>
        private int LcbRetryCount { get; set; } = 0;

        /// <summary>
        /// Maximum time the lcb command is waited until completion before we terminate the request(in seconds).
        /// </summary>
        /// <remarks>The minimum is 1 and the default is 5.</remarks>
        public TimeSpan LcbTimeout { get; set; } = TimeSpan.FromSeconds(5);

        /// <summary>
        /// Consistency level used by n1ql statements in the handler.
        /// </summary>
        /// <remarks>The default is 'none' or 'not bounded'.</remarks>
        public QueryScanConsistency QueryConsistency { get; set; } = QueryScanConsistency.NotBounded;

        /// <summary>
        /// Number of timer shards. defaults to number of vbuckets.
        /// </summary>
        /// <remarks>1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024</remarks>
        public int NumTimerPartitions { get; set; }

        /// <summary>
        /// Batch size for messages from producer to consumer. normally, this must not be specified.
        /// </summary>
        /// <remarks>Default is 1.</remarks>
        public int SockBatchSize { get; set; } = 1;

        /// <summary>
        /// Duration to log stats from this handler, in milliseconds.
        /// </summary>
        /// <remarks>The default is 60000ms.</remarks>
        public int TickDuration { get; set; } = 60000;

        /// <summary>
        /// Size limit of timer context object
        /// </summary>
        /// <remarks>The minimum is 20, the max is 20971520 and the default is 1024.</remarks>
        public int TimerContextSize { get; set; } = 1024;

        /// <summary>
        /// Key prefix for all data stored in metadata by this handler.
        /// </summary>
        /// <remarks>The default is 'eventing'.</remarks>
        public string UserPrefix { get; set; } = "eventing";

        /// <summary>
        /// Maximum size in bytes the bucket cache can grow to.
        /// </summary>
        /// <remarks>The minimum is 20971520 and the default is 67108864.</remarks>
        public int BucketCacheSize { get; set; } = 67108864;

        /// <summary>
        /// Time in milliseconds after which a cached bucket object is considered stale.
        /// </summary>
        /// <remarks>The minimum is 1 and the default is 1000.</remarks>
        public int BucketCacheAge { get; set; } = 1000;

        /// <summary>
        /// Maximum allowable curl call response in 'MegaBytes'. Setting the value to 0 lifts the upper limit off. This parameters affects v8 engine stability since it defines the maximum amount of heap space acquired by a curl call
        /// </summary>
        /// <remarks>The default is 100mb.</remarks>
        public int CurlMaxAllowedRespSize { get; set; } = 100;

        /// <summary>
        /// Automatically prepare all n1ql statements in the handler.
        /// </summary>
        /// <remarks>The default is false.</remarks>
        public bool QueryPrepareAll { get; set; }

        /// <summary>
        /// Number of worker processes handler utilizes on each eventing node.
        /// </summary>
        /// <remarks>The minimum is 1 and the default is 1.</remarks>
        public int WorkerCount { get; set; } = 1;

        /// <summary>
        /// Code to automatically prepend to top of handler code.
        /// </summary>
        public List<string> HandlerHeaders { get; set; } = new();

        /// <summary>
        /// Code to automatically append to bottom of handler code.
        /// </summary>
        public List<string> HandlerFooters { get; set; } = new();

        /// <summary>
        /// Enable rotating this handlers log() message files.
        /// </summary>
        public bool EnableAppLogRotation { get; set; } = true;

        /// <summary>
        /// Directory to write content of log() message files.
        /// </summary>
        public string AppLogDir { get; set; }

        /// <summary>
        /// Rotate logs when file grows to this size in bytes approximately.
        /// </summary>
        /// <remarks>The minimum is 1024b and the max is 41943040b.</remarks>
        public int AppLogMaxSize { get; set; } = 41943040;

        /// <summary>
        /// Number of log() message files to retain when rotating.
        /// </summary>
        /// <remarks>The minimum is 1 and the default is 10.</remarks>
        public int AppLogMaxFiles { get; set; } = 10;

        /// <summary>
        /// Number of seconds before writing a progress checkpoint.
        /// </summary>
        /// <remarks>The minimum is 1 and the default is 60.</remarks>
        public int CheckpointInterval { get; set; } = 1;
    }

    /// <summary>
    /// Indicates where to start dcp stream from (beginning of time, present point) 'from_prior' is deprecated in 6.6.2.
    /// </summary>
    public enum EventingFunctionDcpBoundary
    {
        /// <summary>
        /// Deploy for all data mutations available.
        /// </summary>
        [Description("everything")]
        Everything,

        /// <summary>
        /// Deploy the handler to process only future data mutations, post deployment.
        /// </summary>
        [Description("from_now")]
        FromNow
    }

    /// <summary>
    /// Indicates if the function is deployed. true=deployed, false=undeployed.
    /// </summary>
    public enum EventingFunctionDeploymentStatus
    {
        Deployed,
        // ReSharper disable once IdentifierTypo
        Undeployed
    }

    /// <summary>
    /// Indicates if the function is running (i.e., not paused). true=running, false=paused
    /// </summary>
    public enum EventingFunctionProcessingStatus
    {
        Running,
        Paused
    }

    /// <summary>
    /// The level of detail in system logging.
    /// </summary>
    public enum EventingFunctionLogLevel
    {
        [Description("INFO")] Info,

        [Description("ERROR")] Error,

        [Description("WARNING")] Warning,

        [Description("DEBUG")] Debug,

        [Description("TRACE")] Trace
    }

    /// <summary>
    /// The eventing language version this handler assumes in terms of syntax and behavior.
    /// </summary>
    public enum EventingFunctionLanguageCompatibility
    {
        [Description("6.0.0")]
        Version_6_0_0,

        [Description("6.5.0")]
        Version_6_5_0,

        [Description("6.6.2")]
        Version_6_6_2,
    }
}
